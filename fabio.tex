\documentclass{iucr}

\begin{document}

\title{FabIO: easy access to 2D X-ray detector images in Python}
\shorttitle{FabIO}

    \author[a]{Henning O.}{S$\o$rensen}
    \author[b]{Erik B.}{Knudsen}
    \author[c]{Jonathan P.}{Wright}
	\author[c]{Ga\"el}{Goret}
	\cauthor[c]{J\'er\^ome}{Kieffer}{jerome.kieffer@esrf,fr}{}
% swapped JK & GG to prevent line-jump (cesure) 
    \aff[a]{Nano-Science Center, Department of Chemistry, University of Copenhagen,
            Universitetsparken 5, \city{Copenhagen}, \country{Denmark} }
    \aff[b]{Department of Physics, Technical University of Denmark,
            \city{Kongens Lyngby} \country{Denmark}}
    \aff[c]{European Synchrotron Radiation Facility, \city{Grenoble}, \country{France}}
	\shortauthor{S$\o$rensen et al.}

\maketitle

\section{Introduction}

One obstacle when writing software to analyse data collected from a
two-dimensional detector is to read the raw data into the program,
not least because the data can be stored in many different formats
depending on the instrument used.
To overcome this problem we decided to develop a general module,
FabIO (FABle I/O), to handle reading and writing of two-dimensional
data.
The code-base was initiated by merging parts of our fabian imageviewer
\cite{fabian} and ImageD11 \cite{ImageD11} peak-search programs and has
been developed since 2007 as part of the FABLE \cite{fable} program suite
for analysis of 3DXRD microscopy data \cite{3dxrd}.
While getting integrated in many scientific programs like FitAllB
\cite{fitallb}, the FABLE graphical interface \cite{fable}, EDNA \cite{edna} and
the fast azimuthal integration library, pyFAI \cite{pyfai}; FabIO got
completed with missing features like multi-frame image formats as well as
writing many of the file formats.

We believe FabIO is now ready for a wider audience and could save other
researchers from repeating the work involved in decoding a
binary file format.The table \ref{format} shows the list of file formats that
FabIO can currently (ver. 0.1.0) read.


\section{FabIO Python module}

Python \cite{python} is a scripting language very popular among scientists
which also allows writing well structured application and libraries.

\subsection{Philosophy}

The intention behind this development was to create a Python module which would
enable easy reading of 2D data images, from any detector; without having to
worry about the file format.
Therefore FabIO just needs a file name to open a file and it determines the
file format automatically and deals with gzip \cite{gzip} and bzip2
\cite{bzip2} compression transparently.
An object is returned, which stores the image
{\em data} in memory as a 2D NumPy array \cite{numpy} and the metadata,
called {\em header}, in a python dictionary. Beside the
{\em data} and {\em header} properties, some methods are provided for reading
the {\em previous} or {\em next} image in a series of images as well as jumping
to a specific file number.
For the user, these auxiliary methods are intended to be independent of
the image format (as far as is reasonably possible).

FabIO is written in an object-oriented style (with classes) but aims at being
used in a scripting environment: special care has been set on the ease of
access, especially for scientists with limited knowledge in programming. So
no object-oriented programming is needed to get full benefits of
the library. 
As the development is done in a collaborative and decentralized way; a
comprehensive test suite has been added to prevent any regression during the
development. The software being very modular, allows to include new
classes for handling other data formats quite easily.
FabIO and its source-code are freely available to everyone on-line \cite{fabio}, 
licensed under the GNU General Public License version 3 (GPLv3) and available
directly from popular Linux distribution like Debian and Ubuntu.

\subsection{Implementation}
The main language used in the development of FabIO is Python \cite{python};
however, some image formats are compressed which require
compression algorithms for reading and writing data. When such algorithm cannot
be implemented efficiently using NumPy, we used Python native modules, i.e.
standard C code callable from Python (sometimes generated using Cython
\cite{cython}) and compiled specificaly for the given architecture which
offers excellent performances.
% Generally FabIO have been code in Python \cite{python},
% though for some image formats the python code is merely interfaced a reading
% layer programmed in standard C (sometimes using cython \cite{cython}.
Beside NumPy which is a strong dependency, two optional python
modules can be used in FabIO, namely Lxml, for reading XML files used in EDNA
and the Python Image Library, PIL \cite{pil}.
The PIL module provides useful feature for the display of images and many
image-processing operations not re-implemented in FabIO.
% The PIL representation is useful for displaying images in a GUI based on the Python Tkinter library and also for access
% to the many image processing operations in that library.
% FabIO do not integrate any visualisation tool, but, images can be displayed very
% conveniently using the combination of the library matplotlib \cite{matplotlib} with the interactive python shell IPython \cite{ipython}. 
% 
Images can also be displayed in a convenient interactive manner using
matplotlib \cite{matplotlib} and an IPython shell \cite{ipython}, which is
mainly used for developing data analysis algorithms.
Reading and writing procedure of the various TIFF \cite{tiff} formats is based
on the TiFFIO code from PyMCA \cite{pymca}.

In the Python shell, the {\em fabio} module must be imported prior to reading an
image of one of the supported formats (see Table \ref{format}).
The {\em fabio.open} function creates an instance of the Python class {\em fabioimage},
from the name of a file. This instance, named {\em img} hereafter, stores the
image data in {\em img.data} as a 2D NumPy array. Often the image file contains
furthermore information than just the intensities of the pixels, e.g.
information about how the image is stored and the instrument parameters at the
time of the image acquisition which  are called metadata and usually stored in
the file header.
Header information, are available in {\em img.header} as a Python
dictionary where keys are Python String, values being usually strings or
numeric values.

Currently, FabIO does not attempt to interpret or translate metadata which
is found in the headers of various frame formats, but merely presents the
information as a string. Nevertheless FabIO is capable of converting one
data-format into another, taking care of the numerical specificities: 
for example float array are converted to integer array if the output format only
accepts integers.


\subsection{FabIO methods}

One the strengths of the implementation in an object oriented language as Python
is the possibility to combine functions (or methods) together with data which
are appropriate for specific formats.
In addition to the header information and image data, every {\em fabioimage}
instance (returned by {\em fabio.open}) has methods inherited from fabioimage 
which provide information about the image minimum, maximum and mean values.
There are methods which gives the file number, name etc. One of the most
important methods which actually changes for certain formats  is get next image
in a sequence; these methods are {\em .next()}, {\em .previous()}, and {\em
.getframe(n)}. Of course the behaviour of such methods varies depending on the
image format: if it is single-framed (like mar345),  {\em .next()} will
return the image in next file. On multi-frame format (like GE), {\em .next()} will
return the next frame within the same file. For format wich are possibly multi-framed like
EDF, the behaviour depends on the actual number of frames per file (accessible
via the {\em .nframes} property).


\section{Installation}

As any Python module, FabIO can be installed from its sources available on sourceforge\cite{fabio}
but we advice to use packages provided for the most common
platforms on sourceforge: Windows, MacOSX and Linux. Moreover FabIO is part of
common Linux distribution Ubuntu (since 11.10) and Debian7 where the package is named
{\em python-fabio} and can be install via {\em # apt-get install python-fabio}.

\subsection{Examples}

Opening an image:

\begin{verbatim}
import fabio     
im0 = fabio.open('Quartz_0100.tif') # Open image file
print(im0.data[1024,1024]) # check a pixel value
im1 = im0.next() # Open next image
im270 = im1.getframe(270) # Jump to file number
\end{verbatim}

Normalising the intensity to a value in the header:

\begin{verbatim}
img = fabio.open('exampleimage0001.edf')
print(img.header)
{'ByteOrder': 'LowByteFirst',
 'DATE (scan begin)': 'Mon Jun 28 21:22:16 2010',
 'ESRFCurrent': '198.099',
...
}
# Normalise to beam current and save data
srcur = float(img.header['ESRFCurrent'])
img.data *= 200.0/srcur
img.write('normed_0001.edf')
\end{verbatim}

Interactive viewing with matplotlib:

\begin{verbatim}
import pylab           # pylab is part of matplotlib
pylab.imshow(img.data) # display as an image
pylab.show()           # show GUI window
\end{verbatim}

%\begin{verbatim}
%> import fabio
%> im = fabio.open(’Quartz_0100.tif’)	# Open image file
%> im.data								# Print image data
%> im = im.next()						# Open next image
%> im = im.getframe(270)				# Jump to file number.
%\end{verbatim}


%\begin{verbatim}
%> import fabio 								# import the fabio module
%> img = fabio.open(‘exampleimage0001.edf’) 	# Create a fabioimage instance from the file
%> img.header 								# prints all headers from the file as a python dict.
%{'ByteOrder': 'LowByteFirst',
% 'DATE (scan begin)': 'Mon Jun 28 21:22:16 2010',
% 'DataType': 'UnsignedShort',
% 'Detector': 'frelon4m (sn=29)',
% 'Dim_1': '2048',
% 'Dim_2': '2048',
% 'ESRFAutoTime': '62.2611',
% 'ESRFBeamLine': 'id11',
% 'ESRFCurrent': '200.099',
% 'ESRFFillMode': '7/8 multibunch',
% 'ESRFRefill': '38265',
% 'Experiment': 'ma558',
% 'Fz1': '20.465713',
% 'Fz2': '20.467421',
%……
% 'zb': '22.300000',
% 'zm': '1.239060'}
%> Fz1 = img.header[‘Fz1’]					# retrieve an individual value
%>
%> import pylab								# import pylab from matplotlib
%> pylab.imshow(img.data)					# display as an image
%> pylab.show()								# show window
%\end{verbatim}


\section{Future and perspectives}

Hierarchical data format version 5 \cite{hdf5} is a data format which is
getting popular in the field of X-rays data storage. For now, mainly processed
or curated data are stored in this format but new detector may provide native
output in HDF5 (i.e. the detector Eiger from Dectris is planed to do so). As the
internal structure of HDF5 is very versatile, FabIO will expose specifically
detector images (data and headers) when the internal structure of such files
will be known. H5Py \cite{h5py}, which provides good HDF5 Python binding, is likely to
be used by FabIO for interfacing such files. 

Meanwhile FabIO will be upgraded to Python3; this change of version will affect
a lot of the internal code of FabIO as all string handling and file handling
changed between current Python2 and the new Python3. This change is already
ongoing as many part of native code in C was re-implemented in
Cython \cite{cython} to smooth the transition as Cython generates code 
compatible with Python3. Another issue is the absence of an official PIL port to
Python3, so PIL has already been made an optional dependency and its features could be
reimplemented using other libraries. 

\subsection{Conclusion}

FabIO gives an easy way to read and write 2D images when using the
Python computer language.
It was originally developed for X-ray diffraction but now gives
an easy way for scientists to access and manipulate
their data from a wide range of 2D X-ray detectors.
We welcome contributions to further improve the code and hope to add
further file formats in the future as well as port the existing code base 
to the emerging Python3.


\subsection{acknowledgement}
We acknowledge Andy G\"otz and Kenneth Evans for extensive testing when including
the FabIO reader in the Fable ImageViewer.
We also thank V. Armando Sol\'e for assistance with his TiffIO reader and
Carsten Gundlach for implementation of FabIO at the beamlines i711 and i811, MAX IV and providing bug reports.
We finally acknowledge our colleagues who have reported bugs and helped to
improve FabIO.
Financial support was granted by the EU 6th Framework NEST/ADVENTURE project
TotalCryst.

\bibliographystyle{iucr}
\bibliography{biblio}


\appendix
\section{Various detector format supported by FabIO.}
% put in appendix it can be full width
\onecolumn
\begin{table}[h]

\caption{\label{format}List of file formats that FabIO can read and write}
\vspace{1mm}
\begin{center}
\begin{tabular}{llccc}
Python Module   & Detector		& Typical extension & Multi-image	& Write\\% & Notes\\
\hline % alphabetical order - all formats are equal :-)
adsc	   &   ADSC Quantum		&	.img	&	No	&	Yes		\\%Check\\
bruker		&   Bruker formats		&	.sfrm	&	No	&	Yes		\\%TODO Complete\\
DM3			&						&	.dm3	&	?	&	?		\\%?\\
edf		    &   ESRF data format	&	.edf	&	Yes	&	Yes		\\%Several bit formats\\
EDNA-XML \cite{edna}	& &	.xml	&	No		&	No	 \\%Internaly used in EDNA\cite{edna}\\
cbf		    &   CIF Binary Files	&	.cbf	&	No?	& 	Yes		\\%Used also by Pilatus \\
kcd	    	&   Nonius 	KappaCCD	&	.kccd	&	No 	&	No		\\%Multiples frames are merged are reading. now bruker\\
fit2dmask \cite{fit2d} 	&			&   .msk    &   No  &   Yes  \\
fit2dspreadsheet \cite{fit2d}	&  	&  .spr    &   No  &   Yes    \\
GE		    &   General Electric	&	-		&	Yes	&	No?		\\%massivly multi-frame\\
HiPiC       & Hamamatsu CCDs 		&	.tif	&	No	&	No?	 	\\%Tiff based format\\
marccd		&   MarCCD/Mar165		&	.mccd	&	No	&	No?		\\%Tiff based format\\
mar345		&   Mar345 image plate	&	.mar3450		&	No	&	Yes		\\%Compressed format\\
OXD		    &   Oxford Diffraction 	&	.img	&	No	&	Yes		\\%now Agilent\\
pilatus	    & Dectris Pilatus Tiff	&	.tif	&	No?	&	No?		\\%Tiff based  format\\
PNM			&	Portable aNy Map	& .pnm	&	No	&	?		\\% pnm is a unix image format
TIFF		&	Tagged Image File Format	&	.tif	&	No	&	?		\\%can be compressed or not\\
\end{tabular}
\end{center}
\end{table}

\end{document}
